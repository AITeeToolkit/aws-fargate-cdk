name: Infrastructure Build & Deploy

# Note: Concurrency control is handled by calling workflows (staging-deployment.yml, production-deployment.yml)
# This is a reusable workflow and should not have its own concurrency group to avoid deadlocks

on:
  workflow_call:
    inputs:
      environment:
        description: "Deployment environment (dev/staging/prod)"
        required: true
        type: string
      deploy_all_environments:
        description: "Deploy all environments (dev, staging, prod)"
        required: false
        type: boolean
        default: false
      image_tag:
        description: "Image tag"
        required: false
        type: string
      control_plane_tag:
        description: "Control Plane image tag"
        required: false
        type: string
      api_tag:
        description: "API image tag"
        required: false
        type: string
      web_tag:
        description: "Web image tag"
        required: false
        type: string
  repository_dispatch:
    types: [deploy-infrastructure]
    secrets:
      GH_TOKEN:
        required: true
      AWS_CODEBUILD_ACCESS_KEY_ID:
        required: true
      AWS_CODEBUILD_SECRET_ACCESS_KEY:
        required: true
      AWS_ACCOUNT_ID:
        required: true

env:
  AWS_REGION: us-east-1

jobs:
  deploy:
    name: Deploy Infrastructure
    runs-on: [self-hosted, linux, x64]
    timeout-minutes: 90
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        run: |
          sudo dnf install -y python3 python3-pip
          python3 -m pip install --upgrade pip

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_CODEBUILD_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_CODEBUILD_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install CDK
        run: sudo npm install -g aws-cdk

      - name: Install Python dependencies
        run: pip3 install -r requirements.txt

      - name: Check Stack Status
        id: stack-status
        run: |
          echo "ðŸ” Checking CloudFormation stack status..."

          ENV_NAME="${{ inputs.environment || 'dev' }}"

          # Shared stacks (no environment suffix)
          SHARED_STACKS=(
            "NetworkStack"
            "SharedStack"
            "SharedCertificateStack"
          )

          # Get environment-specific stacks dynamically (exclude Certificate and DomainDns stacks)
          # Include all active stack statuses (including IN_PROGRESS) to detect busy stacks
          ENV_STACKS=$(aws cloudformation list-stacks \
            --stack-status-filter CREATE_COMPLETE UPDATE_COMPLETE UPDATE_ROLLBACK_COMPLETE CREATE_IN_PROGRESS UPDATE_IN_PROGRESS UPDATE_ROLLBACK_IN_PROGRESS \
            --query "StackSummaries[?contains(StackName, '-$ENV_NAME') && !contains(StackName, 'CertificateStack-') && !contains(StackName, 'DomainDnsStack-')].StackName" \
            --output text)

          # Combine shared and environment-specific stacks
          ALL_STACKS=("${SHARED_STACKS[@]}" $ENV_STACKS)

          BUSY_STACKS=()

          for stack in "${ALL_STACKS[@]}"; do
            echo "Checking $stack..."
            STATUS=$(aws cloudformation describe-stacks \
              --stack-name "$stack" \
              --query 'Stacks[0].StackStatus' \
              --output text 2>/dev/null || echo "NOT_FOUND")

            case "$STATUS" in
              *"IN_PROGRESS")
                echo "âš ï¸  $stack is busy: $STATUS"
                BUSY_STACKS+=("$stack:$STATUS")
                ;;
              "NOT_FOUND")
                echo "â„¹ï¸  $stack not found (will be created)"
                ;;
              *)
                echo "âœ… $stack is ready: $STATUS"
                ;;
            esac
          done

          if [ ${#BUSY_STACKS[@]} -gt 0 ]; then
            echo "busy_stacks=true" >> $GITHUB_OUTPUT
            echo "busy_list=${BUSY_STACKS[*]}" >> $GITHUB_OUTPUT
            echo "âŒ Found busy stacks: ${BUSY_STACKS[*]}"
          else
            echo "busy_stacks=false" >> $GITHUB_OUTPUT
            echo "âœ… All stacks are ready for deployment"
          fi

      - name: Install Python dependencies
        run: pip install -r requirements.txt

      - name: CDK Bootstrap
        env:
          JSII_SILENCE_WARNING_DEPRECATED_NODE_VERSION: "1"
        run: cdk bootstrap aws://${{ secrets.AWS_ACCOUNT_ID }}/us-east-1 --force

      - name: Set Image Tags
        run: |
          # Handle both workflow_call inputs and repository_dispatch client_payload
          if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            echo "CONTROL_PLANE_IMAGE_TAG=skip" >> $GITHUB_ENV
            echo "API_IMAGE_TAG=${{ github.event.client_payload.api_tag || 'skip' }}" >> $GITHUB_ENV
            echo "WEB_IMAGE_TAG=${{ github.event.client_payload.web_tag || 'skip' }}" >> $GITHUB_ENV
            echo "ENVIRONMENT=${{ github.event.client_payload.environment || 'dev' }}" >> $GITHUB_ENV
          else
            # For workflow_call, use inputs (which may contain repository dispatch payload)
            echo "CONTROL_PLANE_IMAGE_TAG=${{ inputs.control_plane_tag || 'skip' }}" >> $GITHUB_ENV
            echo "API_IMAGE_TAG=${{ inputs.api_tag || 'skip' }}" >> $GITHUB_ENV
            echo "WEB_IMAGE_TAG=${{ inputs.web_tag || 'skip' }}" >> $GITHUB_ENV
            echo "ENVIRONMENT=${{ inputs.environment || 'dev' }}" >> $GITHUB_ENV
          fi

      - name: Wait for Busy Stacks
        if: steps.stack-status.outputs.busy_stacks == 'true'
        run: |
          echo "â³ Infrastructure is busy, waiting for completion..."
          echo "Busy stacks: ${{ steps.stack-status.outputs.busy_list }}"

          # Wait up to 20 minutes for stacks to become available
          TIMEOUT=1200  # 20 minutes
          ELAPSED=0
          INTERVAL=60   # Check every minute

          while [ $ELAPSED -lt $TIMEOUT ]; do
            echo "â±ï¸  Waiting... ($ELAPSED/$TIMEOUT seconds)"
            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))

            # Re-check stack status
            ALL_READY=true
            STACKS=("NetworkStack" "SharedStack" "MultiAlbStack-$ENVIRONMENT" "APIServiceStack-$ENVIRONMENT" "WebServiceStack-$ENVIRONMENT" "ListenerServiceStack-$ENVIRONMENT" "DNSWorkerServiceStack-$ENVIRONMENT")

            for stack in "${STACKS[@]}"; do
              STATUS=$(aws cloudformation describe-stacks --stack-name "$stack" --query 'Stacks[0].StackStatus' --output text 2>/dev/null || echo "NOT_FOUND")
              if [[ "$STATUS" == *"IN_PROGRESS" ]]; then
                echo "âš ï¸  $stack still busy: $STATUS"
                ALL_READY=false
                break
              fi
            done

            if [ "$ALL_READY" = true ]; then
              echo "âœ… All stacks are now ready!"
              break
            fi
          done

          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "âŒ Timeout waiting for stacks to become ready"
            exit 1
          fi

      - name: Deploy Infrastructure
        if: steps.stack-status.outputs.busy_stacks == 'false' || success()
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "ðŸš€ Deploying with image tags:"
          echo "  Control Plane: $CONTROL_PLANE_IMAGE_TAG"
          echo "  API:        $API_IMAGE_TAG"
          echo "  Web:      $WEB_IMAGE_TAG"

          # Build context parameters
          CONTEXT="--context controlPlaneTag=$CONTROL_PLANE_IMAGE_TAG"
          CONTEXT="$CONTEXT --context apiTag=$API_IMAGE_TAG"
          CONTEXT="$CONTEXT --context webTag=$WEB_IMAGE_TAG"

          # Add environment context based on deploy mode
          if [ "${{ inputs.deploy_all_environments }}" = "true" ]; then
            echo "ðŸŒ Deploying ALL environments: dev, staging, prod"
            CONTEXT="$CONTEXT --context deploy-all=true"
          else
            echo "ðŸŽ¯ Deploying single environment: $ENVIRONMENT"
            CONTEXT="$CONTEXT --context env=$ENVIRONMENT"
          fi

          cdk deploy --all --require-approval never $CONTEXT

      - name: Cleanup Orphaned Certificate Stacks
        run: |
          echo "ðŸ§¹ Cleaning up certificate stacks for inactive domains..."

          # Get ALL certificate stacks (both old and new naming patterns)
          CERT_STACKS=$(aws cloudformation list-stacks \
            --stack-status-filter CREATE_COMPLETE UPDATE_COMPLETE \
            --query "StackSummaries[?starts_with(StackName, 'CertificateStack-')].StackName" \
            --output text)

          if [ -z "$CERT_STACKS" ]; then
            echo "â„¹ï¸  No certificate stacks found"
            exit 0
          fi

          # Check each certificate stack
          for stack in $CERT_STACKS; do
            echo "Checking: $stack"

            # Get certificate ARN from stack outputs
            CERT_ARN=$(aws cloudformation describe-stacks \
              --stack-name "$stack" \
              --query 'Stacks[0].Outputs[?OutputKey==`CertArn`].OutputValue' \
              --output text 2>/dev/null)

            if [ -n "$CERT_ARN" ]; then
              # Check if certificate is in use
              IN_USE=$(aws acm describe-certificate \
                --certificate-arn "$CERT_ARN" \
                --query 'Certificate.InUseBy' \
                --output text 2>/dev/null)

              if [ "$IN_USE" = "None" ] || [ -z "$IN_USE" ]; then
                echo "  ðŸ—‘ï¸  Deleting unused certificate stack"
                aws cloudformation delete-stack --stack-name "$stack" || echo "  âš ï¸  Failed to delete stack"
              else
                echo "  âœ… Certificate in use"
              fi
            else
              echo "  âš ï¸  No certificate ARN found in outputs (old stack format)"
              echo "  ðŸ—‘ï¸  Deleting old-format certificate stack"
              aws cloudformation delete-stack --stack-name "$stack" || echo "  âš ï¸  Failed to delete stack"
            fi
          done

      - name: Deployment Summary
        if: always()
        run: |
          echo "# ðŸš€ Infrastructure Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "## ðŸ”’ Collision Prevention" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.stack-status.outputs.busy_stacks }}" = "true" ]; then
            echo "- â³ **Waited for busy stacks**: ${{ steps.stack-status.outputs.busy_list }}" >> $GITHUB_STEP_SUMMARY
            echo "- ðŸš¦ **Concurrency control**: Active (queued deployment)" >> $GITHUB_STEP_SUMMARY
          else
            echo "- âœ… **No conflicts detected**: All stacks were ready" >> $GITHUB_STEP_SUMMARY
            echo "- ðŸš¦ **Concurrency control**: Active (prevented parallel runs)" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "## ðŸ“‹ Deployment Details" >> $GITHUB_STEP_SUMMARY
          echo "| Service | Tag | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|-----|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Control Plane** | \`$CONTROL_PLANE_IMAGE_TAG\` | ${{ job.status == 'success' && 'âœ… Deployed' || 'âŒ Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **API** | \`$API_IMAGE_TAG\` | ${{ job.status == 'success' && 'âœ… Deployed' || 'âŒ Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Web** | \`$WEB_IMAGE_TAG\` | ${{ job.status == 'success' && 'âœ… Deployed' || 'âŒ Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "## ðŸ”— Quick Links" >> $GITHUB_STEP_SUMMARY
          echo "- [CloudFormation Stacks](https://console.aws.amazon.com/cloudformation/home?region=us-east-1#/stacks)" >> $GITHUB_STEP_SUMMARY
          echo "- [ECS Services](https://console.aws.amazon.com/ecs/home?region=us-east-1#/clusters/storefront-cluster/services)" >> $GITHUB_STEP_SUMMARY
